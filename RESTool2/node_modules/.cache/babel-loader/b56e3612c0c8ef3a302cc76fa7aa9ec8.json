{"ast":null,"code":"import { dataHelpers } from '../helpers/data.helpers';\n\nclass HttpService {\n  constructor(baseUrl = '', unauthorizedRedirectUrl = '', errorMessageDataPath = '') {\n    this.baseUrl = void 0;\n    this.unauthorizedRedirectUrl = void 0;\n    this.errorMessageDataPath = void 0;\n    this.requestHeaders = void 0;\n    this.baseUrl = baseUrl || '';\n    this.unauthorizedRedirectUrl = unauthorizedRedirectUrl || '';\n    this.errorMessageDataPath = errorMessageDataPath || '';\n    this.requestHeaders = {};\n  }\n\n  urlIsAbsolute(url) {\n    if (url.indexOf('http') === 0 || url.indexOf('https') === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  replaceParamsInUrl(url, rawData) {\n    if (!rawData || typeof rawData !== 'object') {\n      return url;\n    }\n\n    let outputUrl = url;\n    Object.keys(rawData).forEach(key => {\n      const urlParamName = `:${key}`;\n      outputUrl = outputUrl.replace(urlParamName, rawData[key]);\n    });\n    return outputUrl;\n  }\n\n  buildUrl(url, queryParams = [], rawData) {\n    if (!queryParams || !queryParams.length) {\n      return this.replaceParamsInUrl(url, rawData);\n    }\n\n    let outputUrl = url;\n    const params = [];\n\n    for (let param of queryParams) {\n      if (!param.name || typeof param.value === 'undefined') {\n        continue;\n      } // TODO: Add docs to \"urlReplaceOnly\"\n\n\n      if (param.urlReplaceOnly) {\n        const urlParamName = `:${param.name}`;\n        outputUrl = outputUrl.replace(urlParamName, param.value);\n      } else {\n        params.push(`${param.name}=${param.value || ''}`);\n      }\n    }\n\n    if (params.length) {\n      const firstSeparator = url.indexOf('?') >= 0 ? '&' : '?';\n      return outputUrl + firstSeparator + params.join('&');\n    }\n\n    return outputUrl;\n  }\n\n  buildRequest(params) {\n    const reqUrl = this.urlIsAbsolute(params.origUrl) ? params.origUrl : this.baseUrl + params.origUrl;\n    const finalUrl = this.buildUrl(reqUrl, params.queryParams, params.rawData);\n    const requestParams = {\n      method: params.method ? params.method.toUpperCase() : 'GET',\n      headers: Object.assign({}, this.requestHeaders, params.headers || {}),\n      body: params.method === 'post' || params.method === 'put' || params.method === 'patch' ? params.body : undefined\n    };\n    return {\n      url: finalUrl,\n      params: requestParams\n    };\n  }\n\n  async getErrorMessage(res) {\n    let errorMessage = '';\n\n    try {\n      const body = await res.json();\n\n      for (const path of this.errorMessageDataPath) {\n        const dataAtPath = dataHelpers.extractDataByDataPath(body, path);\n\n        if (dataAtPath) {\n          errorMessage = dataAtPath;\n        }\n      }\n    } catch {} // TODO: proper handling of errors (^.^)\n\n\n    return errorMessage && errorMessage.length ? errorMessage : `${res.status} - ${res.statusText || ''}`;\n  }\n\n  async handleError(res) {\n    // In case response status is \"Unauthorized\", redirect to relevant url\n    if (res.status === 401 && this.unauthorizedRedirectUrl) {\n      const redirectUrl = this.unauthorizedRedirectUrl.replace(':returnUrl', encodeURIComponent(document.location.href));\n      document.location.href = redirectUrl;\n      return;\n    }\n\n    throw new Error((await this.getErrorMessage(res)));\n  }\n\n  async makeRequest(url, params = {}, responseType = 'json') {\n    const res = await fetch(url, Object.assign({}, params, {}));\n\n    if (res.ok) {\n      switch (responseType) {\n        case 'json':\n          return await res.json();\n\n        case 'text':\n          return await res.text();\n\n        case 'boolean':\n          return true;\n\n        default:\n          return true;\n      }\n    }\n\n    await this.handleError(res);\n  }\n\n  async fetch({\n    method,\n    origUrl,\n    queryParams,\n    rawData,\n    body,\n    headers,\n    responseType\n  }) {\n    const _this$buildRequest = this.buildRequest({\n      method,\n      origUrl,\n      queryParams,\n      rawData,\n      body,\n      headers\n    }),\n          url = _this$buildRequest.url,\n          params = _this$buildRequest.params;\n\n    return await this.makeRequest(url, params, responseType);\n  }\n\n}\n\nexport default HttpService;","map":{"version":3,"sources":["/Users/claire/Desktop/covid-trend/RESTool/src/services/http.service.ts"],"names":["dataHelpers","HttpService","constructor","baseUrl","unauthorizedRedirectUrl","errorMessageDataPath","requestHeaders","urlIsAbsolute","url","indexOf","replaceParamsInUrl","rawData","outputUrl","Object","keys","forEach","key","urlParamName","replace","buildUrl","queryParams","length","params","param","name","value","urlReplaceOnly","push","firstSeparator","join","buildRequest","reqUrl","origUrl","finalUrl","requestParams","method","toUpperCase","headers","assign","body","undefined","getErrorMessage","res","errorMessage","json","path","dataAtPath","extractDataByDataPath","status","statusText","handleError","redirectUrl","encodeURIComponent","document","location","href","Error","makeRequest","responseType","fetch","ok","text"],"mappings":"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","sourcesContent":["import { TConfigMethod, IQueryParam } from '../common/models/config.model';\nimport { dataHelpers } from '../helpers/data.helpers';\n\nexport type ResponseType = 'json' | 'text' | 'boolean' | 'status';\n\nexport interface IFetchParams {\n  origUrl: string\n  method?: TConfigMethod\n  headers?: any\n  queryParams?: IQueryParam[]\n  rawData?: any\n  body?: any\n  responseType?: ResponseType\n}\n\nclass HttpService {\n  public baseUrl: string;\n  public unauthorizedRedirectUrl: string;\n  public errorMessageDataPath: string | string[];\n  public requestHeaders: any;\n\n  constructor(baseUrl: string = '', unauthorizedRedirectUrl: string = '', errorMessageDataPath: string = '') {\n    this.baseUrl = baseUrl || '';\n    this.unauthorizedRedirectUrl = unauthorizedRedirectUrl || '';\n    this.errorMessageDataPath = errorMessageDataPath || '';\n    this.requestHeaders = {};\n  }\n\n  private urlIsAbsolute(url: string) {\n    if (url.indexOf('http') === 0 || url.indexOf('https') === 0) {\n      return true;\n    }\n    return false;\n  }\n\n  private replaceParamsInUrl(url: string, rawData?: any): string {\n    if (!rawData || typeof rawData !== 'object') {\n      return url;\n    }\n\n    let outputUrl = url;\n\n    Object.keys(rawData).forEach((key) => {\n      const urlParamName = `:${key}`;\n      outputUrl = outputUrl.replace(urlParamName, rawData[key] as string);\n    });\n\n    return outputUrl;\n  }\n\n  private buildUrl(url: string, queryParams: IQueryParam[] = [], rawData?: any): string {\n    if (!queryParams || !queryParams.length) {\n      return this.replaceParamsInUrl(url, rawData);\n    }\n\n    let outputUrl = url;\n    const params = [];\n\n    for (let param of queryParams) {\n      if (!param.name || typeof param.value === 'undefined') {\n        continue;\n      }\n\n      // TODO: Add docs to \"urlReplaceOnly\"\n      if (param.urlReplaceOnly) {\n        const urlParamName = `:${param.name}`;\n        outputUrl = outputUrl.replace(urlParamName, param.value as string);\n      } else {\n        params.push(`${param.name}=${param.value || ''}`);\n      }\n    }\n\n    if (params.length) {\n      const firstSeparator = url.indexOf('?') >= 0 ? '&' : '?';\n      return outputUrl + firstSeparator + params.join('&');\n    }\n\n    return outputUrl;\n  }\n\n  private buildRequest(params: IFetchParams): { url: string, params: any } {\n    const reqUrl: string = this.urlIsAbsolute(params.origUrl) ? params.origUrl : this.baseUrl + params.origUrl;\n    const finalUrl: string = this.buildUrl(reqUrl, params.queryParams, params.rawData);\n    const requestParams = {\n      method: params.method ? params.method.toUpperCase() : 'GET',\n      headers: Object.assign({}, this.requestHeaders, params.headers || {}),\n      body: params.method === 'post' || params.method === 'put' || params.method === 'patch' ? params.body : undefined\n    };\n\n    return {\n      url: finalUrl,\n      params: requestParams\n    };\n  }\n\n  private async getErrorMessage(res: Response | any): Promise<string> {\n    let errorMessage: string = '';\n\n    try {\n      const body = await res.json();\n\n      for (const path of this.errorMessageDataPath) {\n        const dataAtPath = dataHelpers.extractDataByDataPath(body, path);\n\n        if (dataAtPath) {\n          errorMessage = dataAtPath;\n        }\n      }\n    } catch { } // TODO: proper handling of errors (^.^)\n\n    return errorMessage && errorMessage.length ?\n      errorMessage :\n      `${res.status} - ${res.statusText || ''}`;\n  }\n\n  private async handleError(res: Response) {\n    // In case response status is \"Unauthorized\", redirect to relevant url\n    if (res.status === 401 && this.unauthorizedRedirectUrl) {\n      const redirectUrl: string = this.unauthorizedRedirectUrl.replace(':returnUrl', encodeURIComponent(document.location.href));\n      document.location.href = redirectUrl;\n      return;\n    }\n\n    throw new Error(await this.getErrorMessage(res));\n  }\n\n  private async makeRequest(url: string, params: any = {}, responseType: ResponseType = 'json') {\n    const res: Response = await fetch(url, Object.assign({}, params, {}));\n\n    if (res.ok) {\n      switch (responseType) {\n        case 'json':\n          return await res.json();\n        case 'text':\n          return await res.text();\n        case 'boolean':\n          return true;\n        default:\n          return true;\n      }\n    }\n\n    await this.handleError(res);\n  }\n\n  public async fetch({ method, origUrl, queryParams, rawData, body, headers, responseType }: IFetchParams) {\n    const { url, params } = this.buildRequest({ method, origUrl, queryParams, rawData, body, headers });\n    return await this.makeRequest(url, params, responseType);\n  }\n}\n\nexport default HttpService;\n"]},"metadata":{},"sourceType":"module"}